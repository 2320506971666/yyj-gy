<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Favicon -->
    <link rel="icon" href="artistweb/images/灰蓝渐变-噪点.jpg">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poiret+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Reenie+Beanie&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">

    <!-- 引入Three.js库 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>

    <!-- 引入Lenis平滑滚动库 -->
    <script src="https://cdn.jsdelivr.net/npm/@studio-freight/lenis@1.0.19/dist/lenis.umd.js"></script>

    <!-- 引入GSAP动画库 -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <title>3D卡片展示 - 水平滚动效果</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #f0f0f0; /* 改为与about.html相同的灰色 */
            color: #333;
            font-family: 'Arial', sans-serif;
            overscroll-behavior: none; /* 防止过度滚动 */
            overflow-x: hidden;
            height: 100vh; /* 确保有完整高度 */
            margin: 0; /* 确保没有边距 */
            padding: 0; /* 确保没有内边距 */

            /* 隐藏滚动条 */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        /* 针对 Chrome、Safari、Opera */
        html::-webkit-scrollbar,
        body::-webkit-scrollbar {
            display: none;
            width: 0;
            height: 0;
        }

        /* 隐藏所有可能的滚动容器的滚动条 */
        ::-webkit-scrollbar {
            display: none;
            width: 0;
            height: 0;
        }

        html {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
            overflow-y: scroll;
        }

        #canvas {
            position: fixed;
            top: 35px; /* 从45px调整为35px，使模型整体向上移动 */
            left: 0;
            z-index: 1;
            width: 100%;
            height: calc(100% - 35px); /* 从45px调整为35px，保持一致 */
        }

        #content {
            position: relative;
            z-index: 2;
            pointer-events: all; /* 允许滚动触发 */
            padding-top: 45px; /* 为导航栏腾出空间 */
        }

        /* 创建可滚动高度 */
        #scroll-height {
            height: 500vh; /* 减小高度，使滚动更容易 */
            width: 100%;
        }

        /* 加载指示器 */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f0f0f0; /* 改为与body背景相同的灰色 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        #loader.hide {
            opacity: 0;
            pointer-events: none;
        }

        .loader-content {
            text-align: center;
        }

        .loader-text {
            font-size: 18px;
            margin-bottom: 20px;
            color: #333; /* 改为深色文字 */
        }

        .progress-bar {
            width: 200px;
            height: 3px;
            background: #ddd; /* 修改进度条背景色 */
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0;
            background: #555; /* 修改进度条填充色 */
            transition: width 0.3s ease;
        }

        /* 导航栏样式 */
        header {
            position: fixed;
            width: 100%;
            top: 0;
            height: 45px;
            background-color: black;
            z-index: 1000;
            padding: 0; /* 移除水平内边距 */
            margin: 0; /* 确保没有外边距 */
            left: 0; /* 确保从左侧开始 */
            right: 0; /* 确保延伸到右侧 */
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            height: 100%;
            margin: 0 auto;
            padding: 0 20px;
        }

        .logo {
            font-family: 'Reenie Beanie', cursive;
            font-size: 2.2rem;
            font-weight: 400;
            letter-spacing: 3px;
            color: #ffffff; /* 修改为白色，与黑色背景搭配 */
            opacity: 0.9;
        }

        .nav-links {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 2.5rem;
        }

        .nav-links a {
            text-decoration: none;
            color: #ffffff; /* 修改为白色，与黑色背景搭配 */
            font-size: 0.9rem;
            font-weight: 300;
            letter-spacing: 3px;
            text-transform: capitalize;
            transition: all 0.4s ease;
            opacity: 0.9;
            font-family: 'Poiret One', cursive;
            position: relative;
        }

        .nav-links a:hover {
            opacity: 1;
            letter-spacing: 4px;
        }

        .nav-links a.active {
            color: #DE2910;
            opacity: 1;
        }

        .nav-links a.active:after {
            display: none; /* 移除下划线 */
        }

        /* 移动端适配样式 */
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }

            /* 移动端导航菜单按钮 */
            .mobile-menu-btn {
                display: block;
                position: absolute;
                right: 20px;
                width: 30px;
                height: 20px;
                cursor: pointer;
                z-index: 10001; /* 提高z-index确保在最上层 */
                padding: 15px; /* 增加内边距扩大点击区域 */
                /* 将点击区域调整为可见区域 */
                top: -10px; /* 上移确保包含所有菜单线条 */
                right: 5px; /* 微调右侧位置 */
            }

            .mobile-menu-btn span {
                display: block;
                position: absolute;
                height: 2px;
                width: 30px; /* 确保宽度固定 */
                background: white;
                opacity: 1;
                left: 15px; /* 根据内边距调整 */
                transform: rotate(0deg);
                transition: .25s ease-in-out;
            }

            .mobile-menu-btn span:nth-child(1) {
                top: 0px;
            }

            .mobile-menu-btn span:nth-child(2) {
                top: 9px;
            }

            .mobile-menu-btn span:nth-child(3) {
                top: 18px;
            }

            .mobile-menu-btn.open span:nth-child(1) {
                top: 9px;
                transform: rotate(135deg);
            }

            .mobile-menu-btn.open span:nth-child(2) {
                opacity: 0;
                left: -60px;
            }

            .mobile-menu-btn.open span:nth-child(3) {
                top: 9px;
                transform: rotate(-135deg);
            }

            /* 移动端菜单样式 */
            .mobile-menu {
                display: none;
                position: fixed;
                top: 45px;
                left: 0;
                width: 100%;
                height: calc(100% - 45px);
                background-color: rgba(0, 0, 0, 0.95); /* 修改为黑色背景 */
                z-index: 999;
                padding: 20px;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }

            .mobile-menu.open {
                display: flex;
            }

            .mobile-menu a {
                color: white; /* 修改为白色 */
                font-size: 1.5rem;
                margin: 15px 0;
                text-decoration: none;
                font-family: 'Poiret One', cursive;
                letter-spacing: 3px;
                transition: all 0.3s ease;
            }

            .mobile-menu a:hover {
                color: #DE2910;
                letter-spacing: 4px;
            }

            .mobile-menu a.active {
                color: #DE2910;
            }
        }

        /* 添加 nav-container 样式 */
        #nav-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 45px;
            background-color: black;
            z-index: 1000;
        }

        /* 添加箭头按钮样式 */
        .arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            border-radius: 50%;
            z-index: 100;
            transition: all 0.3s ease;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 添加通用箭头样式，适用于所有设备 */
        .arrow:before {
            content: '';
            display: block;
            width: 12px;
            height: 12px;
            border-top: 2px solid white;
            border-right: 2px solid white;
            position: absolute;
        }

        .left-arrow:before {
            transform: rotate(-135deg); /* 左箭头 */
            left: 20px; /* 稍微右移一点 */
        }

        .right-arrow:before {
            transform: rotate(45deg); /* 右箭头 */
            right: 20px; /* 稍微左移一点 */
        }

        .arrow:hover {
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .left-arrow {
            left: 30px;
        }

        .right-arrow {
            right: 30px;
        }

        /* 为按钮添加点击效果 */
        .arrow:active {
            transform: translateY(-50%) scale(0.95);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        /* 移动端箭头按钮样式调整 */
        @media (max-width: 768px) {
            .arrow {
                top: 55%; /* 向下移动到屏幕65%位置 */
                width: 45px; /* 略微减小尺寸 */
                height: 45px;
                font-size: 0; /* 隐藏可能的文本内容 */
                background-color: rgba(0, 0, 0, 0.6); /* 稍微提高不透明度 */
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .arrow:active {
                transform: translateY(0) scale(0.95); /* 移动端不需要保持垂直居中 */
            }
            
            .left-arrow {
                left: 15px; /* 向内移动，避免边缘区域不易点击 */
            }
            
            .right-arrow {
                right: 15px; /* 向内移动，避免边缘区域不易点击 */
            }
            
            /* 移动端调整箭头位置 */
            .left-arrow:before {
                left: 18px;
            }
            
            .right-arrow:before {
                right: 18px;
            }
        }

        /* 添加卡片描述区域样式 */
        .card-description {
            position: fixed;
            left: 50%;
            top: 150px; /* 将位置上移，从160px改为150px */
            transform: translateX(-50%);
            width: 40%; /* 减小宽度 */
            max-width: 400px;
            background-color: transparent; /* 移除背景色 */
            padding: 0; /* 移除内边距 */
            z-index: 90;
            opacity: 0;
            filter: blur(0px);
            transition: opacity 0.6s cubic-bezier(0.165, 0.84, 0.44, 1),
                        transform 0.5s cubic-bezier(0.165, 0.84, 0.44, 1),
                        filter 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
            pointer-events: none; /* 防止遮挡模型交互 */
            text-align: center; /* 居中文字 */
            display: block; /* 修改为始终显示，而是用opacity和filter控制可见性 */
        }

        .card-description.active {
            opacity: 1;
            transform: translateX(-50%);
            filter: blur(0px);
        }

        .card-description.fade-out {
            opacity: 0;
            filter: blur(8px);
            transform: translateX(-50%) scale(0.95);
        }

        .card-description.fade-in {
            opacity: 1;
            filter: blur(0px);
            transform: translateX(-50%) scale(1);
        }

        /* 添加图片链接按钮样式 */
        .pictures-link-btn {
            position: fixed;
            left: 30px;
            bottom: 30px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 10px 20px;
            border-radius: 0;
            font-family: 'Poiret One', cursive;
            font-size: 1rem;
            letter-spacing: 2px;
            text-decoration: none;
            transition: all 0.3s ease;
            z-index: 100;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .pictures-link-btn:hover {
            background-color: rgba(222, 41, 16, 0.8);
            border-color: transparent;
            letter-spacing: 3px;
            transform: translateY(-2px);
        }

        /* 响应式调整按钮 */
        @media (max-width: 768px) {
            .pictures-link-btn {
                left: 20px;
                bottom: 80px; /* 将按钮上移，从20px改为120px */
                padding: 8px 15px;
                font-size: 0.9rem;
            }
        }

        /* 底部缩略图条样式 */
        #preview-strip {
            position: fixed;
            bottom: 60px; /* 位置靠上一些 */
            left: 50%;
            transform: translateX(-50%);
            width: 50vw; /* 宽度稍小一些 */
            height: 40px; /* 增加高度从24px到40px，给小圆点留出上方空间 */
            display: flex;
            justify-content: center;
            align-items: flex-end; /* 改为底部对齐，这样缩略图在底部 */
            gap: 10px; /* 增加间隔，从6px改为10px */
            overflow: visible; /* 修改为可见溢出，使小圆点不被裁剪 */
            z-index: 100;
            padding-top: 15px; /* 添加顶部内边距给小圆点留空间 */
        }

        .preview-box {
            width: 48px; /* 宽度放大，从38px改为48px */
            height: 27px; /* 高度放大，保持16:9比例 */
            background: rgba(50, 50, 50, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            position: relative; /* 确保子元素定位生效 */
        }

        .preview-box:hover {
            border-color: rgba(255, 255, 255, 0.8);
            background: rgba(80, 80, 80, 0.4);
            transform: translateY(-2px);
        }

        .preview-box.active {
            border-color: #df5e1e; /* 修改边框颜色从白色改为橙色 */
            border-width: 3px; /* 增加边框宽度 */
            position: relative;
            background: rgba(130, 130, 130, 0.6); /* 更明显的背景色 */
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.6); /* 更明亮的阴影 */
            transform: scale(1.2); /* 放大显示，从1.1改为1.2 */
        }

        /* 移除竖线样式 */
        /*
        .preview-box.active::before,
        .preview-box.active::after {
            content: '';
            position: absolute;
            top: -14px;
            width: 3px;
            height: 16px;
            background: #FFFFFF;
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 1;
            box-shadow: 0 0 8px rgba(255, 255, 255, 1);
        }

        .preview-box.active::before {
            left: 50%;
            transform: translateX(-7px);
        }

        .preview-box.active::after {
            left: 50%;
            transform: translateX(4px);
        }

        .preview-box:not(.active)::before,
        .preview-box:not(.active)::after {
            opacity: 0;
        }
        */

        @media (max-width: 768px) {
            #preview-strip {
                width: 70vw;
                bottom: 40px; /* 移动端位置调整 */
            }

            .preview-box {
                width: 42px; /* 移动端缩略放大，从32px改为42px */
                height: 24px; /* 高度相应调整，保持16:9比例 */
            }
        }

        .card-title {
            font-family: 'Heiti SC', '黑体', 'SimHei', 'Microsoft YaHei', sans-serif; /* 使用黑体字体 */
            font-size: 2.2rem; /* 保持字号 */
            margin: 0; /* 移除边距 */
            color: #333;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7); /* 保留文字阴影 */
        }

        .card-text {
            display: none; /* 隐藏描述文本 */
        }

        /* 在较小屏幕上调整说明文字区域 */
        @media (max-width: 1024px) {
            .card-description {
                width: 70%;
                padding: 0;
                top: 90px; /* 在中等屏幕上稍微上移一点，从100px改为90px */
            }

            .card-title {
                font-size: 1.8rem;
            }
        }

        /* 在移动设备上调整位置 */
        @media (max-width: 768px) {
            .card-title {
                font-size: 1.5rem;
            }
            
            /* 移动端模型位置上移 */
            #canvas {
                margin-top: -100px; /* 将模型向上移动 */
            }
            
            /* 介绍文字位置调整 */
            .card-description {
                top: 170px; /* 文字位置调整，从150px改为120px，在iPhone 11上显示更高 */
                width: 85%;
                max-width: 400px;
            }
            
            /* 缩略图导航向上移动、放大并改为两排布局 */
            #preview-strip {
                bottom: 130px; /* 位置上移，从40px改为80px */
                width: 80vw; /* 宽度扩大，从70vw改为80vw */
                flex-wrap: wrap; /* 允许换行 */
                gap: 1px; /* 增加间距 */
                height: auto; /* 高度自适应内容 */
                justify-content: center; /* 确保居中 */
            }
            
            .preview-box {
                width: 60px; /* 放大缩略图，从42px改为60px */
                height: 34px; /* 保持16:9比例 */
                margin-bottom: 15px; /* 行间距 */
            }
            
            /* 确保两排布局，每排三个 */
            #preview-strip {
                display: grid;
                grid-template-columns: repeat(3, 1fr); /* 3列 */
                grid-template-rows: repeat(2, auto); /* 2行 */
                max-width: 300px; /* 限制最大宽度 */
                margin: 0 auto; /* 添加自动边距实现水平居中 */
                left: 50%; /* 重置左侧位置 */
                transform: translateX(-50%); /* 确保真正居中 */
                place-items: center; /* 确保网格内的项目居中对齐 */
            }
        }

        /* 视频模态框样式 */
        .video-modal {
            display: flex; /* 改为flex并默认隐藏 */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            overflow: hidden;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            /* 删除transition, 由GSAP完全控制 */
            /* transition: background-color 0.8s cubic-bezier(0.165, 0.84, 0.44, 1),
                        opacity 0.8s cubic-bezier(0.165, 0.84, 0.44, 1); */
            padding: 0;
        }

        .video-modal.active {
            background-color: rgba(0, 0, 0, 0.9);
            opacity: 1;
            visibility: visible;
        }

        .video-modal-content {
            position: relative;
            width: 90%;
            max-width: 1200px;
            height: auto;
            max-height: 85vh;
            margin: 0 auto;
            border-radius: 0px; /* 默认无圆角，动画中会改变 */
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(1);
            opacity: 1;
            /* 移除旧的transition，由GSAP控制 */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); /* 添加阴影增强立体感 */
            will-change: transform, opacity, border-radius; /* 提示浏览器优化这些属性的动画 */
        }

        .video-modal.active .video-modal-content {
            transform: scale(1);
            opacity: 1;
        }

        #video-player {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background-color: #000;
            margin: 0;
            padding: 0;
            border: none;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            opacity: 0.8;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        /* 增大移动端关闭按钮点击区域和提高z-index */
        @media (max-width: 768px) {
            .close-modal {
                position: absolute;
                top: 10px;
                right: 15px;
                color: #ffffff;
                font-size: 50px; /* 增大字体大小 */
                font-weight: bold;
                cursor: pointer;
                z-index: 9999; /* 提高z-index确保在最上层 */
                opacity: 0.9;
                padding: 15px; /* 增加内边距扩大点击区域 */
                line-height: 0.6; /* 降低行高，使X更紧凑 */
                background-color: rgba(0, 0, 0, 0.3); /* 添加半透明背景使按钮更明显 */
                border-radius: 50%; /* 圆形背景 */
                width: 40px; /* 设置固定宽度 */
                height: 40px; /* 设置固定高度 */
                display: flex; /* 使用flex布局 */
                justify-content: center; /* 水平居中 */
                align-items: center; /* 垂直居中 */
            }
        }

        .close-modal:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* 小圆点指示器样式 */
        .preview-box {
            position: relative; /* 确保子元素定位生效 */
        }

        .preview-box .dot-indicator {
            position: absolute;
            top: -10px; /* 定位到预览框上方，从-8px改为-10px */
            left: 50%;
            transform: translateX(-50%);
            width: 4px; /* 增大尺寸，从3px改为4px */
            height: 4px; /* 增大尺寸，从3px改为4px */
            background-color: rgb(255, 255, 255);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.3s ease;
            z-index: 101; /* 确保显示在最上层 */
        }

        .preview-box.active .dot-indicator {
            opacity: 1;
            transform: translateX(-50%) scale(1.5); /* 增大缩放比例，从1.3改为1.5 */
            background-color: #df5e1e;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.9); /* 增强发光效果 */
        }

        .copyright {
            text-align: center;
            font-size: 0.7rem;
            padding: 20px 0;
            color: rgba(0, 0, 0, 0.5);
        }
        
        /* 页脚样式 */
        footer {
            background-color: #111;
            color: white;
            padding: 5rem 5% 2rem;
        }
        
        .footer-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 3rem;
            margin-bottom: 3rem;
        }
        
        .footer-column h3 {
            font-size: 1.2rem;
            font-weight: 400;
            margin-bottom: 1.5rem;
            position: relative;
            display: inline-block;
        }
        
        .footer-column h3::after {
            content: '';
            position: absolute;
            height: 1px;
            width: 50px;
            background-color: white;
            bottom: -10px;
            left: 0;
        }
        
        .footer-links {
            list-style: none;
        }
        
        .footer-links li {
            margin-bottom: 0.8rem;
        }
        
        .footer-links a {
            text-decoration: none;
            color: #ccc;
            transition: color 0.3s ease;
        }
        
        .footer-links a:hover {
            color: white;
        }
        
        footer .copyright {
            text-align: center;
            padding-top: 2rem;
            border-top: 1px solid #333;
            font-size: 0.9rem;
            color: #777;
        }
        
        /* 页脚响应式调整 */
        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
        }
    </style>
</head>
<body>
    <!-- 加载指示器 -->
    <div id="loader">
        <div class="loader-content">
            <div class="loader-text">载入中...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>
    </div>

    <!-- 导航栏容器 -->
    <div id="nav-container"></div>

    <!-- 添加左右箭头控制按钮 -->
    <div class="arrow left-arrow" aria-label="上一个"></div>
    <div class="arrow right-arrow" aria-label="下一个"></div>

    <!-- 添加左侧卡片描述区域 -->
    <div class="card-description">
        <h2 class="card-title">项目一</h2>
        <p class="card-text">项目描述内容将在这里显示，随着卡片的切换而更新。这里可以放置项目的详细介绍、创作背景等内容。</p>
    </div>

    <!-- 添加返回图片页面的链接按钮 -->
    <a href="pictures.html" class="pictures-link-btn">←Pictures</a>

    <!-- 添加底部缩略图条 -->
    <div id="preview-strip"></div>

    <!-- 添加视频模态框 -->
    <div class="video-modal" id="video-modal">
        <div class="video-modal-content">
            <span class="close-modal">&times;</span>
            <video id="video-player" controls></video>
        </div>
    </div>

    <!-- Three.js Canvas容器 -->
    <div id="canvas"></div>

    <!-- 创建滚动空间 -->
    <div id="content">
        <div id="scroll-height"></div>
    </div>

    <!-- 加载统一导航栏脚本 -->
    <script src="shared/load-nav.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化变量
            let scene, camera, renderer;
            let cards = [];
            let cardMeshes = [];
            let group;
            let lenis;
            let currentScroll = 0;
            let targetScroll = 0;
            let isScrolling = false;
            let loadedTexturesCount = 0;
            let totalTexturesToLoad = 0;
            let autoRotate = true; // 默认开启自动旋转
            let isAutoRotating = false; // 是否正在自动旋转中
            let autoRotateTime = 0; // 自动旋转计时器
            let currentCardIndex = 0; // 当前显示的卡片索引
            let lastAutoRotateTime = 0; // 上次自动旋转的时间戳
            let autoRotateDelay = 1800; // 自动旋转间隔，毫秒（放慢10倍，原来是50ms）
            let firstCardDelay = 1500; // 第一张卡片停留时间，毫秒（也减少）
            let isFirstCardShown = true; // 标记是否是第一次显示第一张卡片

            // 添加Raycaster用于检测点击
            let raycaster = new THREE.Raycaster();
            let mouse = new THREE.Vector2();
            let isClickable = true; // 标记是否可点击（防止动画过程中点击）

            // 惯性旋转相关变量
            let rotationVelocity = 0;
            let lastScrollSpeed = 0;
            let targetRotation = 0;
            let currentRotation = 0;
            let dampingFactor = 0.45;
            let springStrength = 0.01;
            let scrollMultiplier = 1000; // 极大增加滚动响应
            let overShootFactor = 2.5; // 极大的过冲因子
            let isSnapping = false; // 是否正在对齐到卡片

            // 鼠标移动节流变量
            let mouseMoveRaf = null;

            // 卡片配置
            const totalCards = 6; // 严格六边形的六个顶点
            const cardWidth = 7.5; // 保持卡片宽度
            const cardHeight = 4.22; // 16:9比例的高度
            const radius = 7.4; // 适中的半径，使卡片更聚拢但不挤在一起
            const totalWidth = cardWidth * totalCards;

            // 卡片数据 - 替换为你的实际图片和项目信息
            const cardData = [
                {
                    title: "快闪",
                    image: "artistweb/images/video-posters/快闪视频_4.3.1.jpg",
                    description: "这是项目一的详细描述。这里可以介绍项目的背景、创作理念、制作过程等内容。观众可以通过这段文字更好地理解作品。",
                    videoUrl: "https://assets.tripley.cn/%E9%BB%91%E7%99%BD.mp4" // 快闪视频链接
                },
                {
                    title: "采访",
                    image: "artistweb/images/video-posters/caifang-poster.jpg",
                    description: "这是项目二的详细描述。每个项目都有其独特的故事和意义，通过文字说明可以让观众更深入地了解创作者的想法和项目的价值。",
                    videoUrl: "https://assets.tripley.cn/caifang.mp4" // 采访视频链接
                },
                {
                    title: "情感宣传",
                    image: "artistweb/images/video-posters/bishangan-poster.jpg",
                    description: "这是项目三的详细描述。优秀的项目不仅仅是视觉上的享受，更是思想和情感的传递。这段文字可以帮助建立与观众的情感连接。",
                    videoUrl: "https://assets.tripley.cn/23-10-31-%E5%BF%85%E4%B8%8A%E5%B2%B8.mp4" // 笔尚感视频链接
                },
                {
                    title: "教研宣传",
                    image: "artistweb/images/video-posters/教研视频_4.1.1.jpg",
                    description: "这是项目四的详细描述。每个项目背后都有一个故事，一段经历，或者一个想法。通过这段文字，可以让观众更好地理解创作的初衷。",
                    videoUrl: "https://assets.tripley.cn/24-5-15-%E6%95%99%E7%A0%94%E8%A7%86%E9%A2%91.mp4" // 教研视频链接
                },
                {
                    title: "活动介绍",
                    image: "artistweb/images/video-posters/博饼_2.1.1.jpg",
                    description: "这是项目五的详细描述。好的作品总是能引起共鸣，而详细的文字说明则能帮助建立这种共鸣，让观众产生更深的理解和感受。",
                    videoUrl: "https://assets.tripley.cn/24-9-13-%E5%8D%9A%E9%A5%BC%E6%B4%BB%E5%8A%A8.mp4" // 博饼视频链接
                },
                {
                    title: "基地介绍",
                    image: "artistweb/images/video-posters/jidi-poster.jpg",
                    description: "这是项目六的详细描述。作品的意义往往需要通过文字来阐释，这样才能让观众了解创作者的想法，以及作品所要表达的主题和情感。",
                    videoUrl: "https://assets.tripley.cn/%E5%9F%BA%E5%9C%B0%E4%BB%8B%E7%BB%8D%E8%A7%86%E9%A2%91.mp4" // 基地视频链接
                }
            ];

            // 如果cardData数量不足，复制已有数据填充
            while (cardData.length < totalCards) {
                const originalLength = Math.min(cardData.length, 6);
                for (let i = 0; i < originalLength && cardData.length < totalCards; i++) {
                    cardData.push({...cardData[i]});
                }
            }

            // 获取DOM元素
            const loader = document.getElementById('loader');
            const progressFill = document.getElementById('progress-fill');
            const cardDescription = document.querySelector('.card-description');
            const cardTitle = document.querySelector('.card-title');
            const cardText = document.querySelector('.card-text');

            // 更新加载进度
            function updateProgress(percent) {
                progressFill.style.width = `${percent}%`;
                if (percent >= 100) {
                    setTimeout(() => {
                        loader.classList.add('hide');
                        console.log("加载器已隐藏");
                    }, 500);
                }
            }

            // 优化动画性能设置
            const gsapDefaults = {
                force3D: true, // 强制3D加速
                overwrite: true, // 防止动画冲突
                lazy: false, // 立即更新
                immediateRender: true // 立即渲染第一帧
            };

            // 设置GSAP默认值 - 只保留overwrite属性（其他属性已废弃）
            gsap.defaults({ overwrite: 'auto' });

            // 初始化场景
            function init() {
                console.log("初始化3D场景...");

                // 创建THREE.js场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0); // 改为和背景一样的灰色

                // 创建相机
                const aspect = window.innerWidth / window.innerHeight;
                camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 100);
                camera.position.z = 21; // 适当调整相机距离
                camera.position.y = 0.5; // 与模型组position.y保持一致，向上移动0.5个单位
                camera.position.x = 11; // 与模型组position.x保持一致，确保正对卡片
                console.log("相机位置设置为：", camera.position);

                // 创建渲染器 - 添加优化设置
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    powerPreference: 'high-performance',
                    precision: 'highp'
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比以提高性能
                document.getElementById('canvas').appendChild(renderer.domElement);

                // 添加鼠标移动事件监听，实现悬停效果
                window.addEventListener('mousemove', handleMouseMove);

                // 创建一个组来容纳所有卡片
                group = new THREE.Group();
                scene.add(group);

                // 将整个模型向右移动并稍微上移
                group.position.x = 11; // 向右偏移11个单位
                group.position.y = 0.7; // 稍微向上移动0.5个单位
                console.log("模型组位置设置为：", group.position);

                // 移动端缩放处理
                function applyResponsiveScale() {
                    if (window.innerWidth <= 768) {
                        // 移动端缩放到约0.36倍（0.6*0.6=0.36）
                        group.scale.set(0.5, 0.5, 0.5); // 增大移动端缩放比例从0.36到0.5
                        group.position.y = 0.5; // 调整垂直位置更靠近中心
                        console.log("应用移动端缩放: 0.5");
                    } else {
                        // 恢复桌面端正常大小
                        group.scale.set(1, 1, 1);
                        group.position.y = 0.7; // 恢复原始垂直位置
                        console.log("应用桌面端缩放: 1.0");
                    }
                }
                
                // 初始应用缩放
                applyResponsiveScale();
                
                // 窗口大小改变时重新应用缩放
                window.addEventListener('resize', applyResponsiveScale);

                // 创建卡片
                createCards();

                // 初始化Lenis平滑滚动
                initLenis();

                // 添加事件监听器
                window.addEventListener('resize', onWindowResize);

                // 开始动画循环
                animate();

                console.log("场景初始化完成");
            }

            // 启动自动旋转
            function startAutoRotate() {
                // 如果已经在自动旋转，不重复启动
                if (isAutoRotating) return;

                isAutoRotating = true;
                console.log("自动旋转已启动");

                // 清除可能存在的旧定时器
                stopAllRotateTimers();

                // 用于存储所有自动旋转的定时器ID
                if (!window.autoRotateTimers) {
                    window.autoRotateTimers = [];
                }

                // 直接循环调用自身的函数
                function autoRotateLoop() {
                    if (!isAutoRotating) return; // 如果停止了自动旋转，结束循环

                    // 计算下一个索引
                    const nextIndex = (currentCardIndex + 1) % totalCards;

                    // 如果是第一次显示第一张卡片，使用较长的延迟
                    if (isFirstCardShown && currentCardIndex === 0) {
                        isFirstCardShown = false; // 标记已显示过第一张

                        let timerId = setTimeout(() => {
                            if (isAutoRotating) {
                                // 旋转到下一个卡片，标记为自动旋转
                                rotateTo(nextIndex, true);

                                // 设置下一次旋转
                                let nextTimerId = setTimeout(autoRotateLoop, autoRotateDelay);
                                window.autoRotateTimers.push(nextTimerId);
                            }
                        }, firstCardDelay);

                        window.autoRotateTimers.push(timerId);
                    } else {
                        // 普通情况，使用标准延迟
                        // 旋转到下一个卡片，标记为自动旋转
                        rotateTo(nextIndex, true);

                        // 设置下一次旋转
                        let timerId = setTimeout(autoRotateLoop, autoRotateDelay);
                        window.autoRotateTimers.push(timerId);
                    }
                }

                // 启动循环
                // 先延迟一点，让页面有时间初始化
                let initialTimerId = setTimeout(autoRotateLoop, 100);
                window.autoRotateTimers.push(initialTimerId);
            }

            // 停止所有旋转定时器
            function stopAllRotateTimers() {
                if (window.autoRotateTimers && window.autoRotateTimers.length > 0) {
                    // 清除所有定时器
                    window.autoRotateTimers.forEach(id => clearTimeout(id));
                    window.autoRotateTimers = [];
                }
            }

            // 停止自动旋转
            function stopAutoRotate() {
                isAutoRotating = false;
                stopAllRotateTimers();
                console.log("自动旋转已停止");
            }

            // 创建卡片
            function createCards() {
                const textureLoader = new THREE.TextureLoader();
                totalTexturesToLoad = cardData.length;

                console.log(`开始加载${totalTexturesToLoad}个纹理...`);

                // 计算六边形的角度
                const angleStep = (Math.PI * 2) / totalCards;

                cardData.forEach((data, index) => {
                    // 计算当前卡片的角度 - 从右侧开始，顺时针排列
                    const angle = index * angleStep;

                    // 首先使用默认材质（纹理加载失败时使用）
                    const defaultMaterial = new THREE.MeshBasicMaterial({
                        color: 0x333333,
                        side: THREE.DoubleSide
                    });

                    // 创建几何体 - 使用16:9比例
                    const geometry = new THREE.PlaneGeometry(cardWidth, cardHeight);

                    // 创建网格(使用默认材质)
                    const card = new THREE.Mesh(geometry, defaultMaterial);

                    // 沿六边形顶点放置卡片
                    card.position.x = radius * Math.sin(angle); // 恢复原来的位置计算，不额外偏移
                    card.position.z = radius * Math.cos(angle);
                    card.position.y = 0; // 保持同一高度

                    // 修改卡片朝向，使其面向相机/观众而非中心
                    // 首先面向中心以获取基本朝向
                    card.lookAt(0, 0, 0);
                    // 然后旋转180度，使图片朝向外侧（面向观众）
                    card.rotateY(Math.PI);

                    // 存储卡片初始位置和角度用于动画
                    card.userData = {
                        initialX: card.position.x,
                        initialZ: card.position.z,
                        angle: angle,
                        index: index,
                        data: data // 确保完整的数据对象被存储，包含videoUrl
                    };

                    // 将卡片添加到组和数组中
                    group.add(card);
                    cardMeshes.push(card);
                    cards.push({
                        mesh: card,
                        data: data
                    });

                    // 加载纹理并在就绪时更新材质
                    textureLoader.load(
                        data.image,
                        function(texture) {
                            // 创建带纹理的材质 - 确保纹理不被拉伸
                            const material = new THREE.MeshBasicMaterial({
                                map: texture,
                                side: THREE.DoubleSide
                            });

                            // 设置纹理属性以便实现悬停缩放效果
                            texture.matrixAutoUpdate = true; // 确保材质矩阵可以更新

                            // 保存初始纹理设置，以便我们可以在悬停时缩放
                            material.userData = {
                                originalScale: {x: 1, y: 1},
                                originalOffset: {x: 0, y: 0}
                            };

                            // 调整纹理映射以保持原始比例 - 防止拉伸
                            const imageAspect = texture.image.width / texture.image.height;
                            const geometryAspect = cardWidth / cardHeight;

                            if (imageAspect > geometryAspect) {
                                // 图像比卡片更宽，需要裁剪左右
                                const scale = geometryAspect / imageAspect;
                                texture.repeat.set(scale, 1);
                                texture.offset.set((1 - scale) / 2, 0);

                                // 保存这些初始值
                                material.userData.originalScale = {x: scale, y: 1};
                                material.userData.originalOffset = {x: (1 - scale) / 2, y: 0};
                            } else {
                                // 图像比卡片更高，需要裁剪上下
                                const scale = imageAspect / geometryAspect;
                                texture.repeat.set(1, scale);
                                texture.offset.set(0, (1 - scale) / 2);

                                // 保存这些初始值
                                material.userData.originalScale = {x: 1, y: scale};
                                material.userData.originalOffset = {x: 0, y: (1 - scale) / 2};
                            }

                            // 替换默认材质
                            card.material.dispose();
                            card.material = material;

                            // 更新加载计数和进度
                            loadedTexturesCount++;
                            const progressPercent = (loadedTexturesCount / totalTexturesToLoad) * 100;
                            updateProgress(progressPercent);

                            console.log(`已加载 ${loadedTexturesCount}/${totalTexturesToLoad} 纹理 (${Math.round(progressPercent)}%)`);
                        },
                        null,
                        function(error) {
                            console.error(`加载纹理错误 ${index}:`, error);

                            // 记录错误但仍更新计数器
                            loadedTexturesCount++;
                            updateProgress((loadedTexturesCount / totalTexturesToLoad) * 100);
                        }
                    );
                });

                // 确保即使加载失败也会显示卡片
                setTimeout(() => {
                    if (loadedTexturesCount < totalTexturesToLoad) {
                        updateProgress(100);
                        console.log("部分纹理加载超时，但仍然显示内容");
                    }
                }, 5000);
            }

            // 初始化Lenis平滑滚动
            function initLenis() {
                console.log("初始化Lenis平滑滚动...");

                try {
                    lenis = new Lenis({
                        duration: 1.2,
                        easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
                        direction: 'vertical',
                        gestureDirection: 'vertical',
                        smooth: true,
                        smoothTouch: true,
                        touchMultiplier: 3
                    });

                    // 上一次滚动位置
                    let prevScroll = 0;

                    // 获取Lenis的滚动值
                    lenis.on('scroll', (e) => {
                        // 如果正在对齐中，不响应滚动
                        if (isSnapping) return;

                        // 计算滚动速度
                        const scrollDelta = e.scroll - prevScroll;
                        prevScroll = e.scroll;

                        // 记录目标滚动位置
                        targetScroll = e.scroll;

                        // 滚动处理 - 直接触发卡片切换而非连续旋转
                        if (Math.abs(scrollDelta) > 5) {
                            // 判断滚动方向并触发相应的卡片切换
                            if (scrollDelta > 0) {
                                goToNextCard();
                            } else {
                                goToPrevCard();
                            }
                        }
                    });

                    function raf(time) {
                        lenis.raf(time);
                        requestAnimationFrame(raf);
                    }

                    requestAnimationFrame(raf);

                    // 根据卡片数量设置滚动高度
                    const scrollHeight = 500;
                    document.getElementById('scroll-height').style.height = `${scrollHeight}vh`;

                    console.log("Lenis初始化完成");
                } catch (error) {
                    console.log(`Lenis初始化失败: ${error.message}`);
                }
            }

            // 更新组旋转 - 根据滚动位置旋转整个卡片组
            function updateGroupRotation() {
                const maxScroll = document.body.scrollHeight - window.innerHeight;
                const scrollProgress = targetScroll / maxScroll;

                // 计算目标旋转角度 - 完整的一周旋转
                targetRotation = scrollProgress * Math.PI * 2;
            }

            // 自动对齐到最近的卡片
            let scrollEndTimer;
            function snapToNearestCard() {
                if (isScrolling || isSnapping) return;

                // 计算当前旋转角度最接近哪个卡片
                const currentAngle = group.rotation.y % (Math.PI * 2);
                const normalizedAngle = currentAngle < 0 ? currentAngle + Math.PI * 2 : currentAngle;

                // 卡片角度间隔
                const cardAngleStep = (Math.PI * 2) / totalCards;

                // 找到最近的卡片索引
                const cardIndex = Math.round(normalizedAngle / cardAngleStep) % totalCards;

                // 使用统一的旋转函数
                rotateTo(cardIndex);
            }

            // 处理窗口调整大小
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // 主动画循环 - 优化渲染
            function animate(time) {
                requestAnimationFrame(animate);

                // 应用旋转 - 仅在需要时渲染
                if (!isSnapping) {
                    group.rotation.y = currentRotation;
                }

                // 渲染场景
                renderer.render(scene, camera);
            }

            // 创建底部缩略图
            function createPreviewBoxes() {
                const previewStrip = document.getElementById('preview-strip');

                // 清空现有内容
                previewStrip.innerHTML = '';

                // 为每个卡片创建一个预览框
                for (let i = 0; i < totalCards; i++) {
                    const box = document.createElement('div');
                    box.className = 'preview-box';
                    if (i === 0) {
                        box.classList.add('active');
                    }

                    // 添加小圆点作为当前状态指示器
                    const dot = document.createElement('div');
                    dot.className = 'dot-indicator';
                    box.appendChild(dot);

                    // 添加图片预览 - 使用卡片的图片作为缩略图
                    if (cardData[i] && cardData[i].image) {
                        box.style.backgroundImage = `url(${cardData[i].image})`;
                        box.style.backgroundSize = 'cover';
                        box.style.backgroundPosition = 'center';
                    }

                    // 添加点击事件 - 优化防止重复触发
                    box.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        // 停止任何自动旋转
                        stopAutoRotate();

                        // 旋转到对应卡片
                        rotateTo(i, false, true);

                        // 注释掉自动打开视频的代码，仅旋转到对应卡片
                        /*
                        // 直接调用视频模态框，传入缩略图DOM
                        if (cardData[i] && cardData[i].videoUrl) {
                            setTimeout(() => {
                                openVideoModal(cardData[i].videoUrl, box);
                            }, 400);
                        }
                        */
                    });

                    previewStrip.appendChild(box);
                }

                // 初始化高亮第一项
                updateHighlight(0);
            }

            // 打开视频模态框的函数
            function openVideoModal(videoUrl, clickedElement) {
                // 获取模态框和视频播放器元素
                const modal = document.getElementById('video-modal');
                const videoPlayer = document.getElementById('video-player');
                const modalContent = document.querySelector('.video-modal-content');
                
                // 检测是否为Safari浏览器
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                
                console.log("打开视频模态框，是否Safari:", isSafari);
                
                // 设置视频源
                videoPlayer.src = videoUrl;
                
                // Safari特定处理：确保加载元数据
                if (isSafari) {
                    videoPlayer.load();
                }

                // 计算元素边界
                let thumbRect;

                if (clickedElement && clickedElement.getBoundingClientRect) {
                    // 如果传入了DOM元素，直接获取其边界
                    thumbRect = clickedElement.getBoundingClientRect();
                } else if (clickedElement && clickedElement.clientX) {
                    // 如果传入的是事件对象，创建一个虚拟的边界框，以点击位置为中心
                    thumbRect = {
                        left: clickedElement.clientX - 100,
                        top: clickedElement.clientY - 56.25,
                        width: 200,
                        height: 112.5,
                        right: clickedElement.clientX + 100,
                        bottom: clickedElement.clientY + 56.25
                    };

                    // 记录点击位置，用于关闭动画
                    lastClickPosition = { x: clickedElement.clientX, y: clickedElement.clientY };
                } else {
                    // 如果没有有效元素或事件，使用屏幕中心
                    thumbRect = {
                        left: window.innerWidth / 2 - 100,
                        top: window.innerHeight / 2 - 56.25,
                        width: 200,
                        height: 112.5,
                        right: window.innerWidth / 2 + 100,
                        bottom: window.innerHeight / 2 + 56.25
                    };

                    // 使用屏幕中心作为点击位置
                    lastClickPosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                }

                // 保存点击的元素，用于关闭动画
                modal.clickedElement = clickedElement;

                // 1) 先立即显示modal
                gsap.set(modal, { visibility: 'visible' });
                modal.classList.add('active');

                // 确保显示内容区域（防止getBoundingClientRect失败）
                modalContent.style.display = 'flex';

                // 先获取模态内容的目标大小和位置
                const destRect = modalContent.getBoundingClientRect();

                // 计算从缩略图到模态框的缩放和位置差异
                const scaleX = thumbRect.width / destRect.width;
                const scaleY = thumbRect.height / destRect.height;
                const x = (thumbRect.left + thumbRect.width/2) - (destRect.left + destRect.width/2);
                const y = (thumbRect.top + thumbRect.height/2) - (destRect.top + destRect.height/2);

                // 2) 创建timeline
                const tl = gsap.timeline({
                    onComplete: () => {
                        // 视频自动播放安全处理
                        videoPlayer.muted = true;
                        
                        // 对于Safari，使用不同的播放方法
                        if (isSafari) {
                            // 监听元数据加载完成事件
                            videoPlayer.onloadedmetadata = function() {
                                console.log("Safari: 视频元数据已加载");
                                // 尝试播放
                                const playPromise = videoPlayer.play();
                                if (playPromise !== undefined) {
                                    playPromise.catch(err => {
                                        console.warn('Safari视频播放失败，尝试使用点击触发:', err);
                                        // 创建一个透明的按钮覆盖视频
                                        const playButton = document.createElement('div');
                                        playButton.style.position = 'absolute';
                                        playButton.style.top = '0';
                                        playButton.style.left = '0';
                                        playButton.style.width = '100%';
                                        playButton.style.height = '100%';
                                        playButton.style.zIndex = '10';
                                        playButton.style.cursor = 'pointer';
                                        modalContent.appendChild(playButton);
                                        
                                        // 点击播放
                                        playButton.addEventListener('click', function() {
                                            videoPlayer.play();
                                            playButton.remove();
                                        });
                                    });
                                }
                            };
                            videoPlayer.load(); // 确保重新加载元数据
                        } else {
                            // 非Safari浏览器
                            videoPlayer.play().catch(err => {
                                console.warn('视频自动播放失败：', err);
                                // 创建播放按钮
                                const playButton = document.createElement('div');
                                playButton.style.position = 'absolute';
                                playButton.style.top = '0';
                                playButton.style.left = '0';
                                playButton.style.width = '100%';
                                playButton.style.height = '100%';
                                playButton.style.zIndex = '10';
                                playButton.style.cursor = 'pointer';
                                modalContent.appendChild(playButton);
                                
                                // 点击播放
                                playButton.addEventListener('click', function() {
                                    videoPlayer.play();
                                    playButton.remove();
                                });
                            });
                        }
                    }
                });

                // 3) 背景蒙层淡入
                tl.fromTo(modal,
                    { opacity: 0 },
                    { opacity: 1, duration: 0.4, ease: 'power2.out' },
                    0
                );

                // 4) 设置初始「英雄」位置/缩放
                tl.set(modalContent, {
                    transformOrigin: 'center center',
                    x, y, scaleX, scaleY, opacity: 1
                }, 0);

                // 5) 与背景同时，放大并移回中心
                tl.to(modalContent, {
                    x: 0, y: 0, scaleX: 1, scaleY: 1,
                    duration: 0.6, ease: 'power3.out'
                }, 0);
            }

            // 处理卡片点击事件
            function handleCardClick(event) {
                // 如果点击的是预览条或其子元素，不处理
                if (event.target.closest('#preview-strip')) {
                    return;
                }

                // 如果点击的是左右箭头，不处理
                if (event.target.closest('.arrow')) {
                    return;
                }

                // 计算鼠标归一化坐标
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

                // 更新射线
                raycaster.setFromCamera(mouse, camera);

                // 检测射线与卡片的相交
                const intersects = raycaster.intersectObjects(cardMeshes);

                if (intersects.length > 0) {
                    // 获取点击的卡片
                    const clickedCard = intersects[0].object;
                    const cardIndex = clickedCard.userData.index;
                    const cardData = clickedCard.userData.data;

                    console.log("点击卡片:", cardIndex, "当前卡片:", currentCardIndex);

                    // 暂停自动旋转
                    stopAutoRotate();

                    // 只要卡片有视频并且可以看到（是射线检测到的第一个），就直接打开视频
                    if (cardData && cardData.videoUrl) {
                        console.log("打开视频:", cardData.title);
                        // 传递点击事件作为clickedElement
                        openVideoModal(cardData.videoUrl, event);
                    }

                    // 3秒后恢复自动旋转
                    setTimeout(startAutoRotate, 3000);
                }
            }

            // 新增：处理移动端触摸结束事件（相当于点击）
            function handleTouchEnd(event) {
                // 防止默认行为，避免干扰我们的视频打开
                event.preventDefault();
                
                // 获取触摸结束的位置
                const touch = event.changedTouches[0];
                
                // 判断是否是简单的点击（非滑动）
                if (Math.abs(touchEndX - touchStartX) < 10) { // 如果移动距离小，视为点击而非滑动
                    console.log("检测到移动端点击事件");
                    
                    // 如果点击的是预览条或其子元素，不处理
                    if (event.target.closest('#preview-strip')) {
                        return;
                    }

                    // 如果点击的是左右箭头，不处理
                    if (event.target.closest('.arrow')) {
                        return;
                    }
                    
                    // 创建一个模拟的鼠标事件对象，用于光线投射
                    const fakeMouseEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                    
                    // 计算触摸点的归一化坐标
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (touch.clientY / window.innerHeight) * 2 + 1;
                    
                    // 更新射线
                    raycaster.setFromCamera(mouse, camera);
                    
                    // 在移动设备上扩大射线检测范围
                    raycaster.far = 100; // 增加射线检测距离
                    raycaster.params.Line.threshold = 0.3; // 增加线的检测阈值
                    raycaster.params.Points.threshold = 0.3; // 增加点的检测阈值
                    
                    // 检测射线与卡片的相交
                    const intersects = raycaster.intersectObjects(cardMeshes);
                    
                    // 如果没有直接点击到卡片，尝试检测点击是否接近当前卡片
                    if (intersects.length === 0) {
                        console.log("未直接点击到卡片，检查是否靠近当前卡片");
                        
                        // 获取当前显示的卡片
                        const currentCard = cardMeshes[currentCardIndex];
                        if (currentCard && currentCard.userData && currentCard.userData.data && currentCard.userData.data.videoUrl) {
                            // 屏幕点击位置与当前卡片的中心位置比较
                            const cardWorldPosition = new THREE.Vector3();
                            currentCard.getWorldPosition(cardWorldPosition);
                            
                            // 将世界坐标转换为屏幕坐标
                            const cardScreenPosition = cardWorldPosition.clone();
                            cardScreenPosition.project(camera);
                            
                            // 计算点击位置与卡片屏幕中心的距离
                            const cardScreenX = (cardScreenPosition.x + 1) / 2 * window.innerWidth;
                            const cardScreenY = - (cardScreenPosition.y - 1) / 2 * window.innerHeight;
                            const clickDistance = Math.sqrt(
                                Math.pow(touch.clientX - cardScreenX, 2) + 
                                Math.pow(touch.clientY - cardScreenY, 2)
                            );
                            
                            console.log("点击距离卡片中心:", clickDistance, "像素");
                            
                            // 如果点击位置与当前卡片中心的距离在合理范围内，也打开视频
                            // 在移动设备上使用更大的阈值
                            const clickThreshold = window.innerWidth * 0.4; // 屏幕宽度的40%作为阈值
                            if (clickDistance < clickThreshold) {
                                console.log("点击在当前卡片附近，打开视频:", currentCard.userData.data.title);
                                stopAutoRotate();
                                openVideoModal(currentCard.userData.data.videoUrl, fakeMouseEvent);
                                setTimeout(startAutoRotate, 3000);
                                return;
                            }
                        }
                    }
                    
                    if (intersects.length > 0) {
                        // 获取点击的卡片
                        const clickedCard = intersects[0].object;
                        const cardIndex = clickedCard.userData.index;
                        const cardData = clickedCard.userData.data;
                        
                        console.log("触摸到卡片:", cardIndex, "当前卡片:", currentCardIndex);
                        
                        // 暂停自动旋转
                        stopAutoRotate();
                        
                        // 如果卡片有视频，打开视频模态框
                        if (cardData && cardData.videoUrl) {
                            console.log("移动端打开视频:", cardData.title);
                            // 传递触摸事件作为clickedElement
                            openVideoModal(cardData.videoUrl, fakeMouseEvent);
                        }
                        
                        // 3秒后恢复自动旋转
                        setTimeout(startAutoRotate, 3000);
                    }
                }
            }

            // 统一的旋转到指定卡片的函数
            function rotateTo(idx, isAutoRotating = false, isDirectClick = false) {
                // 如果正在旋转中，且不是强制旋转（自动或直接点击），则忽略
                if (isSnapping ) {
                    console.log('忽略旋转请求：动画正在进行中');
                    return;
                }

                // 规范化索引，确保在有效范围内
                idx = ((idx % totalCards) + totalCards) % totalCards;

                // 如果请求旋转到当前已经显示的卡片，直接跳过（除非是自动旋转）
                if (idx === currentCardIndex && !isAutoRotating) {
                    console.log('已经是当前卡片，跳过旋转');
                    return;
                }

                // 如果不是自动旋转，暂停自动旋转
                if (!isAutoRotating) {
                    stopAutoRotate();
                }

                // 立即将标志设为true以阻止新的旋转请求
                isSnapping = true;

                // 立即锁定点击事件，防止在旋转过程中点击
                isClickable = false;

                // 更新描述文字和高亮
                updateCardDescription(idx);
                updateHighlight(idx); // 提前更新高亮，让UI立即响应

                // 计算卡片角度间隔
                const cardAngleStep = (Math.PI * 2) / totalCards;

                // 计算目标旋转角度 - 确保使用正确的角度公式
                // 注意：这里的目标角度需要与卡片的摆放角度对应
                const baseTargetAngle = -idx * cardAngleStep;

                // 为了确保最短路径旋转，我们需要考虑当前角度
                // 先获取当前group的y轴旋转角度，并将其规范化到[0, 2π)范围内
                let currentRotationY = group.rotation.y;

                // 找到最接近当前旋转角度的等效目标角度
                // 计算当前旋转角度的等价角度集合中，距离目标角度最近的那个
                // 旋转角度每转一圈相当于加减2π

                // 计算当前角度除以2π的余数（规范化到一个周期内）
                const normalizedCurrentRotation = currentRotationY % (Math.PI * 2);
                const positiveNormalizedRotation = normalizedCurrentRotation < 0 ?
                    normalizedCurrentRotation + Math.PI * 2 : normalizedCurrentRotation;

                // 计算目标角度和当前角度之间可能的差值（考虑正向和负向）
                let angleDiff = baseTargetAngle - positiveNormalizedRotation;

                // 如果差值超过π，说明反向旋转更近
                if (Math.abs(angleDiff) > Math.PI) {
                    angleDiff = angleDiff > 0 ?
                        angleDiff - Math.PI * 2 : // 顺时针转过头，改为逆时针
                        angleDiff + Math.PI * 2;  // 逆时针转过头，改为顺时针
                }

                // 如果角度差异很小，直接设置为完成
                if (Math.abs(angleDiff) < 0.01) {
                    isSnapping = false;
                    isClickable = true; // 恢复点击
                    currentRotation = currentRotationY;
                    currentCardIndex = idx; // 确保更新当前索引
                    console.log('角度差异很小，跳过动画');
                    return;
                }

                // 计算最终目标角度（当前角度加上最小角度差）
                const finalTargetAngle = currentRotationY + angleDiff;

                // 添加日志以便调试
                console.log(`从 ${currentRotationY.toFixed(2)} 旋转到 ${finalTargetAngle.toFixed(2)}, 角度差: ${angleDiff.toFixed(2)}, idx: ${idx}`);

                // 确定过冲方向
                const overshootAmount = Math.sign(angleDiff) * -cardAngleStep * 0.05;
                const overshootAngle = finalTargetAngle + overshootAmount;

                // 动画持续时间和缓动函数 - 统一旋转速度
                const duration = 0.7; // 动画时长

                // 在动画开始前，先取消所有现有的GSAP动画
                gsap.killTweensOf(group.rotation);

                // 保存目标索引，用于动画完成后的确认
                const targetIdx = idx;

                // 创建动画 - 使用单个更流畅的动画代替分段动画
                const tl = gsap.timeline({
                    onComplete: function() {
                        // 动画完成后设置标志
                        isSnapping = false;
                        isClickable = true; // 恢复点击
                        currentRotation = finalTargetAngle;

                        // 再次确认当前索引和高亮
                        currentCardIndex = targetIdx;
                        updateHighlight(targetIdx);

                        // 非自动旋转时才设置延迟恢复自动旋转
                        if (!isAutoRotating) {
                            // 3秒后恢复自动旋转
                            setTimeout(startAutoRotate, 3000);
                        }
                    }
                });

                // 使用单一的流畅动画，使用贝塞尔曲线缓动函数
                tl.to(group.rotation, {
                    y: finalTargetAngle,
                    duration: duration,
                    ease: "sine.inOut" // 使用正弦曲线实现更平滑的过渡
                });
            }

            // 更新卡片描述内容
            function updateCardDescription(index) {
                // 规范化索引，确保在有效范围内
                index = ((index % totalCards) + totalCards) % totalCards;

                // 获取卡片数据
                const card = cardData[index];

                // 创建模糊淡出效果
                cardDescription.classList.remove('active');
                cardDescription.classList.remove('fade-in');
                cardDescription.classList.add('fade-out');

                // 延迟更新内容，等待淡出完成
                setTimeout(() => {
                    // 更新描述内容 - 只显示标题
                    cardTitle.textContent = card.title;

                    // 创建模糊淡入效果
                    cardDescription.classList.remove('fade-out');
                    cardDescription.classList.add('fade-in');
                    setTimeout(() => {
                        cardDescription.classList.add('active');
                    }, 50);
                }, 300); // 对应淡出动画时间
            }

            // 更新底部缩略图高亮
            function updateHighlight(idx) {
                // 规范化索引，确保在有效范围内
                idx = ((idx % totalCards) + totalCards) % totalCards;

                console.log("更新高亮：", idx);

                // 更新底部缩略图高亮
                const boxes = document.querySelectorAll('.preview-box');
                boxes.forEach((box, i) => {
                    if (i === idx) {
                        box.classList.add('active');
                    } else {
                        box.classList.remove('active');
                    }
                });

                // 可选：用GSAP添加淡入效果
                const activeBox = boxes[idx];
                if (activeBox) {
                    gsap.fromTo(activeBox,
                        { opacity: 0.6 },
                        { opacity: 1, duration: 0.4, ease: 'power2.out' }
                    );
                }

                // 更新当前卡片索引
                currentCardIndex = idx;
            }

            // 切换到下一张卡片
            function goToNextCard(isDirectClick = false) {
                // 使用统一的旋转函数
                rotateTo(currentCardIndex + 1, false, isDirectClick);
            }

            // 切换到上一张卡片
            function goToPrevCard(isDirectClick = false) {
                // 使用统一的旋转函数
                rotateTo(currentCardIndex - 1, false, isDirectClick);
            }

            // 添加鼠标点击事件监听器，用于卡片点击
            window.addEventListener('click', handleCardClick);
            
            // 添加移动端触摸结束事件监听器，用于卡片点击
            window.addEventListener('touchend', handleTouchEnd);

            // 添加触摸滑动和鼠标滑动事件
            let touchStartX = 0;
            let touchEndX = 0;

            // 触摸事件
            window.addEventListener('touchstart', function(event) {
                touchStartX = event.touches[0].clientX;
            });

            window.addEventListener('touchend', function(event) {
                touchEndX = event.changedTouches[0].clientX;
                handleSwipe();
            });

            // 鼠标事件
            let isMouseDown = false;
            let mouseStartX = 0;
            let mouseEndX = 0;

            window.addEventListener('mousedown', function(event) {
                isMouseDown = true;
                mouseStartX = event.clientX;
            });

            window.addEventListener('mouseup', function(event) {
                if (isMouseDown) {
                    mouseEndX = event.clientX;
                    isMouseDown = false;
                    handleMouseSwipe();
                }
            });

            // 处理触摸滑动
            function handleSwipe() {
                const swipeThreshold = 50; // 滑动阈值
                const swipeDistance = touchEndX - touchStartX;

                if (swipeDistance > swipeThreshold) {
                    // 向右滑动，显示上一张卡片
                    goToPrevCard();
                } else if (swipeDistance < -swipeThreshold) {
                    // 向左滑动，显示下一张卡片
                    goToNextCard();
                }
            }

            // 处理鼠标滑动
            function handleMouseSwipe() {
                const swipeThreshold = 50; // 滑动阈值
                const swipeDistance = mouseEndX - mouseStartX;

                if (swipeDistance > swipeThreshold) {
                    // 向右滑动，显示上一张卡片
                    goToPrevCard();
                } else if (swipeDistance < -swipeThreshold) {
                    // 向左滑动，显示下一张卡片
                    goToNextCard();
                }
            }

            // 键盘事件处理函数
            function handleKeyDown(event) {
                if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
                    goToNextCard(true); // 传递isDirectClick=true参数
                } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
                    goToPrevCard(true); // 传递isDirectClick=true参数
                }
            }

            // 添加鼠标移动事件监听，实现悬停效果
            function handleMouseMove(event) {
                if (!camera) return;

                // 使用RAF节流
                if (mouseMoveRaf) cancelAnimationFrame(mouseMoveRaf);
                mouseMoveRaf = requestAnimationFrame(() => {
                // 计算鼠标归一化坐标
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

                // 更新射线
                raycaster.setFromCamera(mouse, camera);

                // 检测射线与卡片的相交
                const intersects = raycaster.intersectObjects(cardMeshes);

                // 重置所有卡片的样式
                cardMeshes.forEach(card => {
                    // 恢复原始尺寸
                    if (card.userData.isHovered && card.material.map) {
                        // 重置卡片的缩放
                        card.scale.set(1, 1, 1);

                        // 恢复纹理原始参数
                        if (card.material.userData && card.material.userData.originalScale) {
                            const origScale = card.material.userData.originalScale;
                            const origOffset = card.material.userData.originalOffset;

                            // 使用GSAP平滑过渡回原始状态
                            gsap.to(card.material.map.repeat, {
                                x: origScale.x,
                                y: origScale.y,
                                duration: 0.4,
                                ease: "power2.out"
                            });

                            gsap.to(card.material.map.offset, {
                                x: origOffset.x,
                                y: origOffset.y,
                                duration: 0.4,
                                ease: "power2.out"
                            });
                        }

                        card.userData.isHovered = false;
                    }
                });

                // 如果有卡片被悬停，变更鼠标样式并处理纹理放大
                if (intersects.length > 0) {
                    document.body.style.cursor = 'pointer';
                    const hoveredCard = intersects[0].object;

                    // 标记为悬停状态
                    hoveredCard.userData.isHovered = true;

                    // 如果卡片有纹理和保存的原始数据
                    if (hoveredCard.material && hoveredCard.material.map &&
                        hoveredCard.material.userData && hoveredCard.material.userData.originalScale) {

                        const texture = hoveredCard.material.map;
                        const origScale = hoveredCard.material.userData.originalScale;
                        const origOffset = hoveredCard.material.userData.originalOffset;

                        // 计算放大比例 (稍微放大纹理，相当于缩小比例值)
                        const zoomFactor = 0.9; // 缩放比例，调整此值可以改变放大程度
                        const newScaleX = origScale.x * zoomFactor;
                        const newScaleY = origScale.y * zoomFactor;

                        // 计算新的偏移值，以保持图像居中
                        const newOffsetX = origOffset.x + (origScale.x - newScaleX) / 2;
                        const newOffsetY = origOffset.y + (origScale.y - newScaleY) / 2;

                        // 使用GSAP平滑过渡到放大状态
                        gsap.to(texture.repeat, {
                            x: newScaleX,
                            y: newScaleY,
                            duration: 0.8,
                            ease: "power2.out"
                        });

                        gsap.to(texture.offset, {
                            x: newOffsetX,
                            y: newOffsetY,
                            duration: 0.8,
                            ease: "power2.out"
                        });
                    }
                } else {
                    document.body.style.cursor = 'auto';
                }
                });
            }

            // 初始化一切
            setTimeout(() => {
                init();

                // 创建底部缩略图
                createPreviewBoxes();

                // 初始化左侧描述文字 - 仅在加载完成后显示
                setTimeout(() => {
                    updateCardDescription(0);
                    cardDescription.classList.add('active');

                    // 确保第一张卡片高亮
                    updateHighlight(0);

                    // 启动自动旋转功能 - 第一张卡片会停留更长时间
                    isFirstCardShown = true; // 确保初始状态为第一次显示
                    currentCardIndex = 0;    // 确保从第一张卡片开始
                    startAutoRotate();
                }, 500);

                // 添加箭头按钮事件 - 使用isDirectClick=true标志
                const leftArrow = document.querySelector('.left-arrow');
                const rightArrow = document.querySelector('.right-arrow');

                leftArrow.addEventListener('click', () => {
                    // 手动左箭头点击需要标记为直接点击
                    goToPrevCard(true);
                });

                rightArrow.addEventListener('click', () => {
                    // 手动右箭头点击需要标记为直接点击
                    goToNextCard(true);
                });

                // 添加单一的键盘事件监听器，移除重复的监听器
                window.removeEventListener('keydown', handleKeyDown); // 先移除可能存在的监听器
                window.addEventListener('keydown', handleKeyDown);

                // 添加鼠标点击事件监听器，用于卡片点击
                window.addEventListener('click', handleCardClick);
                
                // 添加移动端触摸结束事件监听器，用于卡片点击
                window.addEventListener('touchend', handleTouchEnd);

                // 添加模态框关闭事件
                const modal = document.getElementById('video-modal');
                const closeBtn = document.querySelector('.close-modal');
                const videoPlayer = document.getElementById('video-player');

                // 存储上次点击位置，用于关闭动画
                let lastClickPosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

                // 点击关闭按钮
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault(); // 阻止默认行为
                    e.stopPropagation(); // 阻止事件冒泡
                    closeVideoModal();
                });

                // 添加触摸事件监听器，确保在移动设备上也能正常关闭
                closeBtn.addEventListener('touchend', function(e) {
                    e.preventDefault(); // 阻止默认行为
                    e.stopPropagation(); // 阻止事件冒泡
                    closeVideoModal();
                });

                // 点击模态框外部区域
                window.addEventListener('click', function(event) {
                    if (event.target == modal) {
                        closeVideoModal();
                    }
                });

                // 按ESC键关闭模态框
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        closeVideoModal();
                    }
                });

                // 关闭视频模态框的函数
                function closeVideoModal() {
                    console.log("执行关闭视频模态框");
                    const modal = document.getElementById('video-modal');
                    const modalContent = document.querySelector('.video-modal-content');
                    const videoPlayer = document.getElementById('video-player');
                    
                    try {
                        // 确保视频停止播放
                        if (videoPlayer) {
                            videoPlayer.pause();
                            videoPlayer.currentTime = 0;
                        }
                        
                        // 立即隐藏模态框
                        modal.classList.remove('active');
                        modal.style.visibility = 'hidden';
                        modal.style.opacity = '0';
                        
                        // 清除视频源，确保完全释放资源
                        if (videoPlayer) {
                            videoPlayer.src = '';
                        }
                        
                        console.log("视频模态框已关闭");
                    } catch (error) {
                        console.error("关闭视频模态框时出错:", error);
                    }
                }
            }, 100);
        });
    </script>
    
    <!-- 页脚 -->
    <footer>
        <div class="footer-content">
            <div class="footer-column">
                <h3>Contact</h3>
                <p>yang2320506971@gmail.com</p>
            </div>
            <div class="footer-column">
                <h3>Navigation</h3>
                <ul class="footer-links">
                    <li><a href="film.html">Film</a></li>
                    <li><a href="gallery.html">Gallery</a></li>
                    <li><a href="work.html">Work</a></li>
                    <li><a href="about.html">About</a></li>
                </ul>
            </div>
            <div class="footer-column">
                <h3>Gallery</h3>
                <ul class="footer-links">
                    <li><a href="tibet.html">Tibet</a></li>
                    <li><a href="north.html">Northern Journey</a></li>
                    <li><a href="film.html">Summer Sense</a></li>
                    <li><a href="sanya.html">Island</a></li>
                </ul>
            </div>
        </div>
        <div class="copyright">
            © 2025 Artist Portfolio. All rights reserved.
        </div>
    </footer>
</body>
</html>

